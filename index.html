<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Black Sheep Meadow Runner</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            text-align: center;
            z-index: 100;
        }
        #instructions h2 {
            margin: 0 0 10px 0;
            font-size: 24px;
        }
        #instructions p {
            margin: 5px 0;
            font-size: 14px;
        }

        /* Mobile controls */
        .mobile-controls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            pointer-events: none;
        }

        .mobile-controls.active {
            display: block;
        }

        .mobile-button {
            position: absolute;
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.3);
            border: 3px solid rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            user-select: none;
            touch-action: none;
            pointer-events: auto;
            transition: background 0.1s;
        }

        .mobile-button.pressed {
            background: rgba(255, 255, 255, 0.6);
        }

        .mobile-button.rect {
            border-radius: 15px;
            width: 100px;
            font-size: 16px;
            font-weight: bold;
        }

        .joystick-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 140px;
            height: 140px;
        }

        .joystick-base {
            position: absolute;
            width: 140px;
            height: 140px;
            background: rgba(255, 255, 255, 0.2);
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            pointer-events: auto;
            touch-action: none;
        }

        .joystick-knob {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.6);
            border: 3px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: background 0.1s;
            pointer-events: none;
        }

        .joystick-base.active .joystick-knob {
            background: rgba(255, 255, 255, 0.9);
        }

        .action-buttons {
            position: absolute;
            bottom: 30px;
            right: 30px;
        }

        #btn-jump {
            position: absolute;
            bottom: 80px;
            right: 0;
        }

        #btn-sprint {
            position: absolute;
            bottom: 0;
            right: 0;
        }

        /* Minimap */
        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            border: 3px solid rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.5);
            z-index: 50;
        }
    </style>
</head>
<body>
    <div id="instructions">
        <h2>Black Sheep Meadow Runner</h2>
        <p class="desktop-only"><strong>WASD</strong> or <strong>Arrow Keys</strong> to move</p>
        <p class="desktop-only"><strong>Shift</strong> to sprint</p>
        <p class="desktop-only"><strong>Space</strong> to jump</p>
        <p class="mobile-only" style="display:none;">Use on-screen controls to play</p>
    </div>

    <!-- Minimap -->
    <canvas id="minimap" width="200" height="200"></canvas>

    <!-- Mobile Controls -->
    <div class="mobile-controls" id="mobileControls">
        <div class="joystick-container">
            <div class="joystick-base" id="joystick">
                <div class="joystick-knob" id="joystick-knob"></div>
            </div>
        </div>
        <div class="action-buttons">
            <div class="mobile-button rect" id="btn-jump">JUMP</div>
            <div class="mobile-button rect" id="btn-sprint">SPRINT</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Detect mobile device
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
                         || (window.innerWidth <= 768);

        // Show/hide appropriate controls
        if (isMobile) {
            document.getElementById('mobileControls').classList.add('active');
            document.querySelectorAll('.desktop-only').forEach(el => el.style.display = 'none');
            document.querySelectorAll('.mobile-only').forEach(el => el.style.display = 'block');
        }

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue
        scene.fog = new THREE.Fog(0x87CEEB, 50, 200);

        // Camera setup
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 8, 15);

        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 50, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -50;
        directionalLight.shadow.camera.right = 50;
        directionalLight.shadow.camera.top = 50;
        directionalLight.shadow.camera.bottom = -50;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Create black sheep
        class Sheep {
            constructor() {
                this.group = new THREE.Group();

                // Body
                const bodyGeometry = new THREE.BoxGeometry(1.5, 1, 2);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
                this.body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                this.body.position.y = 1;
                this.body.castShadow = true;
                this.group.add(this.body);

                // Head
                const headGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                const headMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
                this.head = new THREE.Mesh(headGeometry, headMaterial);
                this.head.position.set(0, 1.2, 1.2);
                this.head.castShadow = true;
                this.group.add(this.head);

                // Eyes
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.25, 1.3, 1.6);
                this.group.add(leftEye);

                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.25, 1.3, 1.6);
                this.group.add(rightEye);

                // Pupils
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(-0.25, 1.3, 1.65);
                this.group.add(leftPupil);

                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(0.25, 1.3, 1.65);
                this.group.add(rightPupil);

                // Legs
                const legGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.8, 8);
                const legMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });

                this.legs = [];
                const legPositions = [
                    [-0.5, 0.4, 0.6],
                    [0.5, 0.4, 0.6],
                    [-0.5, 0.4, -0.6],
                    [0.5, 0.4, -0.6]
                ];

                legPositions.forEach(pos => {
                    const leg = new THREE.Mesh(legGeometry, legMaterial);
                    leg.position.set(pos[0], pos[1], pos[2]);
                    leg.castShadow = true;
                    this.group.add(leg);
                    this.legs.push(leg);
                });

                // Ears
                const earGeometry = new THREE.ConeGeometry(0.2, 0.4, 8);
                const earMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
                const leftEar = new THREE.Mesh(earGeometry, earMaterial);
                leftEar.position.set(-0.3, 1.6, 1.2);
                leftEar.rotation.z = 0.3;
                this.group.add(leftEar);

                const rightEar = new THREE.Mesh(earGeometry, earMaterial);
                rightEar.position.set(0.3, 1.6, 1.2);
                rightEar.rotation.z = -0.3;
                this.group.add(rightEar);

                this.velocity = new THREE.Vector3();
                this.isJumping = false;
            }

            update(keys, delta) {
                const baseSpeed = 35;
                const sprintMultiplier = keys['ShiftLeft'] || keys['ShiftRight'] ? 1.8 : 1;
                const speed = baseSpeed * sprintMultiplier;
                const rotationSpeed = 3;

                // Rotation
                if (keys['KeyA'] || keys['ArrowLeft']) {
                    this.group.rotation.y += rotationSpeed * delta;
                }
                if (keys['KeyD'] || keys['ArrowRight']) {
                    this.group.rotation.y -= rotationSpeed * delta;
                }

                // Forward/backward movement
                if (keys['KeyW'] || keys['ArrowUp']) {
                    this.velocity.x += Math.sin(this.group.rotation.y) * speed * delta;
                    this.velocity.z += Math.cos(this.group.rotation.y) * speed * delta;
                    this.animateLegs(delta, sprintMultiplier);
                }
                if (keys['KeyS'] || keys['ArrowDown']) {
                    this.velocity.x -= Math.sin(this.group.rotation.y) * speed * delta;
                    this.velocity.z -= Math.cos(this.group.rotation.y) * speed * delta;
                    this.animateLegs(delta, sprintMultiplier);
                }

                // Jumping
                if (keys['Space'] && !this.isJumping) {
                    this.velocity.y = 6;
                    this.isJumping = true;
                    playJumpSound();
                }

                // Apply gravity
                this.velocity.y -= 20 * delta;

                // Store old position for collision resolution
                const oldX = this.group.position.x;
                const oldZ = this.group.position.z;

                // Update position
                this.group.position.add(this.velocity.clone().multiplyScalar(delta));

                // Check collision with obstacles
                const collision = checkCollision(this.group.position.x, this.group.position.z, 1.5);
                if (collision.collided) {
                    // Revert position
                    this.group.position.x = oldX;
                    this.group.position.z = oldZ;
                    // Stop velocity in collision direction
                    this.velocity.x *= 0.1;
                    this.velocity.z *= 0.1;
                }

                // Ground collision
                if (this.group.position.y <= 0) {
                    this.group.position.y = 0;
                    this.velocity.y = 0;
                    this.isJumping = false;
                }

                // Apply friction
                this.velocity.x *= 0.9;
                this.velocity.z *= 0.9;
            }

            animateLegs(delta, speedMultiplier = 1) {
                const time = Date.now() * 0.01 * speedMultiplier;
                this.legs.forEach((leg, index) => {
                    const offset = index < 2 ? 0 : Math.PI;
                    leg.rotation.x = Math.sin(time + offset) * 0.3;
                });
            }
        }

        // Create meadow ground
        const groundSize = 200;
        const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize, 50, 50);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x4CAF50 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Add some terrain variation
        const vertices = ground.geometry.attributes.position.array;
        for (let i = 0; i < vertices.length; i += 3) {
            vertices[i + 2] = Math.random() * 0.5;
        }
        ground.geometry.attributes.position.needsUpdate = true;
        ground.geometry.computeVertexNormals();

        // Add grass blades
        function createGrass() {
            const grassGroup = new THREE.Group();
            const grassGeometry = new THREE.ConeGeometry(0.1, 1, 3);
            const grassMaterial = new THREE.MeshLambertMaterial({ color: 0x2E7D32 });

            for (let i = 0; i < 500; i++) {
                const grass = new THREE.Mesh(grassGeometry, grassMaterial);
                grass.position.x = (Math.random() - 0.5) * groundSize * 0.8;
                grass.position.z = (Math.random() - 0.5) * groundSize * 0.8;
                grass.position.y = 0.5;
                grass.rotation.y = Math.random() * Math.PI * 2;
                grass.scale.y = 0.5 + Math.random() * 0.5;
                grassGroup.add(grass);
            }
            scene.add(grassGroup);
        }
        createGrass();

        // Add flowers
        function createFlowers() {
            const flowerGroup = new THREE.Group();
            const colors = [0xFF69B4, 0xFFFF00, 0xFF6347, 0xFF00FF, 0xFFFFFF];

            for (let i = 0; i < 100; i++) {
                const stemGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.5, 4);
                const stemMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const stem = new THREE.Mesh(stemGeometry, stemMaterial);

                const petalGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                const petalMaterial = new THREE.MeshLambertMaterial({
                    color: colors[Math.floor(Math.random() * colors.length)]
                });
                const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                petal.position.y = 0.25;

                const flower = new THREE.Group();
                flower.add(stem);
                flower.add(petal);
                flower.position.x = (Math.random() - 0.5) * groundSize * 0.8;
                flower.position.z = (Math.random() - 0.5) * groundSize * 0.8;
                flower.position.y = 0.25;

                flowerGroup.add(flower);
            }
            scene.add(flowerGroup);
        }
        createFlowers();

        // Add trees
        function createTrees() {
            for (let i = 0; i < 20; i++) {
                const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 3, 8);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.castShadow = true;

                const foliageGeometry = new THREE.SphereGeometry(2, 8, 8);
                const foliageMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                foliage.position.y = 3;
                foliage.castShadow = true;

                const tree = new THREE.Group();
                tree.add(trunk);
                tree.add(foliage);
                tree.position.y = 1.5;

                // Position trees around the edges
                const angle = (i / 20) * Math.PI * 2;
                const distance = groundSize * 0.4;
                tree.position.x = Math.cos(angle) * distance;
                tree.position.z = Math.sin(angle) * distance;

                scene.add(tree);
            }
        }
        createTrees();

        // Add fence around the meadow
        function createFence() {
            const fenceGroup = new THREE.Group();
            const fenceSize = groundSize * 0.45;
            const postSpacing = 8;
            const postCount = Math.floor((fenceSize * 4) / postSpacing);

            for (let i = 0; i < postCount; i++) {
                const fence = new THREE.Group();

                // Fence post
                const postGeometry = new THREE.BoxGeometry(0.3, 2.5, 0.3);
                const postMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const post = new THREE.Mesh(postGeometry, postMaterial);
                post.position.y = 1.25;
                post.castShadow = true;
                fence.add(post);

                // Horizontal rails
                for (let j = 0; j < 3; j++) {
                    const railGeometry = new THREE.BoxGeometry(postSpacing, 0.2, 0.2);
                    const railMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const rail = new THREE.Mesh(railGeometry, railMaterial);
                    rail.position.y = 0.5 + j * 0.7;
                    rail.position.x = postSpacing / 2;
                    fence.add(rail);
                }

                // Position fence posts around perimeter
                const side = Math.floor(i / (postCount / 4));
                const posInSide = i % (postCount / 4);

                if (side === 0) { // North
                    fence.position.x = -fenceSize + posInSide * postSpacing;
                    fence.position.z = fenceSize;
                    fence.rotation.y = Math.PI; // Rotated 90째 more
                } else if (side === 1) { // East
                    fence.position.x = fenceSize;
                    fence.position.z = fenceSize - posInSide * postSpacing;
                    fence.rotation.y = Math.PI / 2; // Rotated 90째
                } else if (side === 2) { // South
                    fence.position.x = fenceSize - posInSide * postSpacing;
                    fence.position.z = -fenceSize;
                    fence.rotation.y = Math.PI; // Rotated 90째 more
                } else { // West
                    fence.position.x = -fenceSize;
                    fence.position.z = -fenceSize + posInSide * postSpacing;
                    fence.rotation.y = Math.PI / 2; // Rotated 90째
                }

                fenceGroup.add(fence);
            }

            scene.add(fenceGroup);
            return fenceGroup;
        }
        const fence = createFence();

        // Add farmhouse
        function createFarmhouse() {
            const farmhouse = new THREE.Group();

            // Main house body
            const houseGeometry = new THREE.BoxGeometry(12, 6, 10);
            const houseMaterial = new THREE.MeshLambertMaterial({ color: 0xCC0000 });
            const house = new THREE.Mesh(houseGeometry, houseMaterial);
            house.position.y = 3;
            house.castShadow = true;
            farmhouse.add(house);

            // Roof
            const roofGeometry = new THREE.ConeGeometry(8.5, 4, 4);
            const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 8;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            farmhouse.add(roof);

            // Door
            const doorGeometry = new THREE.BoxGeometry(2, 3.5, 0.2);
            const doorMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 1.75, 5.1);
            farmhouse.add(door);

            // Windows
            const windowGeometry = new THREE.BoxGeometry(1.5, 1.5, 0.2);
            const windowMaterial = new THREE.MeshLambertMaterial({ color: 0x87CEEB });
            const window1 = new THREE.Mesh(windowGeometry, windowMaterial);
            window1.position.set(-3, 3.5, 5.1);
            farmhouse.add(window1);

            const window2 = new THREE.Mesh(windowGeometry, windowMaterial);
            window2.position.set(3, 3.5, 5.1);
            farmhouse.add(window2);

            // Position farmhouse
            farmhouse.position.set(groundSize * 0.35, 0, groundSize * 0.35);
            farmhouse.rotation.y = -Math.PI / 4;

            scene.add(farmhouse);
            return farmhouse;
        }
        const farmhouse = createFarmhouse();

        // Add office copying machine in the middle
        function createCopyingMachine() {
            const copyingMachine = new THREE.Group();

            // Main body (large rectangular base)
            const bodyGeometry = new THREE.BoxGeometry(4, 2, 3);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xE0E0E0 }); // Light gray
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1;
            body.castShadow = true;
            copyingMachine.add(body);

            // Scanner section (top part)
            const scannerBaseGeometry = new THREE.BoxGeometry(3.6, 0.4, 2.6);
            const scannerBaseMaterial = new THREE.MeshLambertMaterial({ color: 0xB0B0B0 }); // Darker gray
            const scannerBase = new THREE.Mesh(scannerBaseGeometry, scannerBaseMaterial);
            scannerBase.position.y = 2.2;
            scannerBase.castShadow = true;
            copyingMachine.add(scannerBase);

            // Scanner lid (slightly raised and angled)
            const scannerLidGeometry = new THREE.BoxGeometry(3.6, 0.25, 2.6);
            const scannerLidMaterial = new THREE.MeshLambertMaterial({ color: 0x303030 }); // Dark gray
            const scannerLid = new THREE.Mesh(scannerLidGeometry, scannerLidMaterial);
            scannerLid.position.set(0, 2.7, -0.3);
            scannerLid.rotation.x = -0.3; // Slightly open
            scannerLid.castShadow = true;
            copyingMachine.add(scannerLid);

            // Control panel (angled display)
            const controlPanelGeometry = new THREE.BoxGeometry(1.5, 0.8, 0.15);
            const controlPanelMaterial = new THREE.MeshLambertMaterial({ color: 0x1E1E1E }); // Black
            const controlPanel = new THREE.Mesh(controlPanelGeometry, controlPanelMaterial);
            controlPanel.position.set(1.2, 2.3, 1.65);
            controlPanel.rotation.x = -0.5;
            controlPanel.rotation.y = -0.2;
            copyingMachine.add(controlPanel);

            // Display screen (small green screen)
            const screenGeometry = new THREE.BoxGeometry(0.8, 0.4, 0.05);
            const screenMaterial = new THREE.MeshLambertMaterial({ color: 0x00FF00, emissive: 0x00AA00 }); // Green glow
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.set(1.25, 2.42, 1.75);
            screen.rotation.x = -0.5;
            screen.rotation.y = -0.2;
            copyingMachine.add(screen);

            // Buttons on control panel
            const buttonGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.05, 8);
            const buttonColors = [0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00]; // Red, Green, Blue, Yellow

            for (let i = 0; i < 4; i++) {
                const buttonMaterial = new THREE.MeshLambertMaterial({ color: buttonColors[i] });
                const button = new THREE.Mesh(buttonGeometry, buttonMaterial);
                button.position.set(1.1 + (i * 0.2), 2.12, 1.72);
                button.rotation.x = Math.PI / 2;
                copyingMachine.add(button);
            }

            // Paper input tray
            const inputTrayGeometry = new THREE.BoxGeometry(3, 0.1, 2);
            const inputTrayMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF }); // White paper
            const inputTray = new THREE.Mesh(inputTrayGeometry, inputTrayMaterial);
            inputTray.position.set(-0.5, 0.8, -1.2);
            inputTray.rotation.x = 0.3;
            copyingMachine.add(inputTray);

            // Paper output tray
            const outputTrayGeometry = new THREE.BoxGeometry(2.5, 0.1, 1.8);
            const outputTrayMaterial = new THREE.MeshLambertMaterial({ color: 0xF5F5F5 }); // Off-white
            const outputTray = new THREE.Mesh(outputTrayGeometry, outputTrayMaterial);
            outputTray.position.set(0.3, 0.3, 1.5);
            outputTray.rotation.x = -0.2;
            copyingMachine.add(outputTray);

            // Brand logo (small colored rectangle on front)
            const logoGeometry = new THREE.BoxGeometry(0.8, 0.3, 0.05);
            const logoMaterial = new THREE.MeshLambertMaterial({ color: 0x0066CC }); // Blue logo
            const logo = new THREE.Mesh(logoGeometry, logoMaterial);
            logo.position.set(-1.5, 1.5, 1.55);
            copyingMachine.add(logo);

            // Power button (small green circle)
            const powerButtonGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.06, 16);
            const powerButtonMaterial = new THREE.MeshLambertMaterial({ color: 0x00FF00, emissive: 0x00AA00 });
            const powerButton = new THREE.Mesh(powerButtonGeometry, powerButtonMaterial);
            powerButton.position.set(-1.8, 1.8, 1.56);
            powerButton.rotation.x = Math.PI / 2;
            copyingMachine.add(powerButton);

            // Position in the middle of the meadow
            copyingMachine.position.set(0, 0, 0);

            scene.add(copyingMachine);
            return copyingMachine;
        }
        const copyingMachine = createCopyingMachine();

        // Add hay bales
        function createHayBales() {
            const hayBaleGroup = new THREE.Group();

            for (let i = 0; i < 10; i++) {
                const hayBale = new THREE.Group();

                // Main bale body
                const baleGeometry = new THREE.CylinderGeometry(0.8, 0.8, 1.5, 16);
                const baleMaterial = new THREE.MeshLambertMaterial({ color: 0xDEB887 });
                const bale = new THREE.Mesh(baleGeometry, baleMaterial);
                bale.rotation.z = Math.PI / 2;
                bale.castShadow = true;
                hayBale.add(bale);

                // Position hay bales randomly
                hayBale.position.x = (Math.random() - 0.5) * groundSize * 0.7;
                hayBale.position.z = (Math.random() - 0.5) * groundSize * 0.7;
                hayBale.position.y = 0.8;
                hayBale.rotation.y = Math.random() * Math.PI * 2;

                hayBaleGroup.add(hayBale);
            }

            scene.add(hayBaleGroup);
            return hayBaleGroup;
        }
        const hayBales = createHayBales();

        // Create collision objects array for obstacles
        const collisionObjects = [];

        // Add fence collision boundaries
        const fenceSize = groundSize * 0.45;
        collisionObjects.push({
            type: 'rectangle',
            x: 0,
            z: fenceSize,
            width: fenceSize * 2,
            depth: 2,
            name: 'fence-north'
        });
        collisionObjects.push({
            type: 'rectangle',
            x: 0,
            z: -fenceSize,
            width: fenceSize * 2,
            depth: 2,
            name: 'fence-south'
        });
        collisionObjects.push({
            type: 'rectangle',
            x: fenceSize,
            z: 0,
            width: 2,
            depth: fenceSize * 2,
            name: 'fence-east'
        });
        collisionObjects.push({
            type: 'rectangle',
            x: -fenceSize,
            z: 0,
            width: 2,
            depth: fenceSize * 2,
            name: 'fence-west'
        });

        // Add farmhouse collision
        collisionObjects.push({
            type: 'rectangle',
            x: groundSize * 0.35,
            z: groundSize * 0.35,
            width: 12,
            depth: 10,
            name: 'farmhouse'
        });

        // Add copying machine collision
        collisionObjects.push({
            type: 'rectangle',
            x: 0,
            z: 0,
            width: 4.5,
            depth: 3.5,
            name: 'copying-machine'
        });

        // Add hay bale collisions
        hayBales.children.forEach((hayBale, index) => {
            collisionObjects.push({
                type: 'circle',
                x: hayBale.position.x,
                z: hayBale.position.z,
                radius: 1.2,
                name: `haybale-${index}`
            });
        });

        // Add tree collisions (from earlier tree creation)
        for (let i = 0; i < 20; i++) {
            const angle = (i / 20) * Math.PI * 2;
            const distance = groundSize * 0.4;
            collisionObjects.push({
                type: 'circle',
                x: Math.cos(angle) * distance,
                z: Math.sin(angle) * distance,
                radius: 2.5,
                name: `tree-${i}`
            });
        }

        // Collision detection function
        function checkCollision(x, z, radius) {
            for (const obj of collisionObjects) {
                if (obj.type === 'circle') {
                    const dx = x - obj.x;
                    const dz = z - obj.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    if (distance < radius + obj.radius) {
                        return { collided: true, obj, dx, dz, distance };
                    }
                } else if (obj.type === 'rectangle') {
                    const halfWidth = obj.width / 2;
                    const halfDepth = obj.depth / 2;

                    // Find closest point on rectangle to circle
                    const closestX = Math.max(obj.x - halfWidth, Math.min(x, obj.x + halfWidth));
                    const closestZ = Math.max(obj.z - halfDepth, Math.min(z, obj.z + halfDepth));

                    const dx = x - closestX;
                    const dz = z - closestZ;
                    const distance = Math.sqrt(dx * dx + dz * dz);

                    if (distance < radius) {
                        return { collided: true, obj, dx, dz, distance };
                    }
                }
            }
            return { collided: false };
        }

        // Add clouds
        function createClouds() {
            const cloudGroup = new THREE.Group();

            for (let i = 0; i < 10; i++) {
                const cloud = new THREE.Group();
                const cloudMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });

                for (let j = 0; j < 5; j++) {
                    const cloudGeometry = new THREE.SphereGeometry(1 + Math.random() * 0.5, 8, 8);
                    const cloudPart = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    cloudPart.position.x = (Math.random() - 0.5) * 3;
                    cloudPart.position.y = (Math.random() - 0.5) * 1;
                    cloud.add(cloudPart);
                }

                cloud.position.x = (Math.random() - 0.5) * groundSize;
                cloud.position.y = 20 + Math.random() * 10;
                cloud.position.z = (Math.random() - 0.5) * groundSize;
                cloudGroup.add(cloud);
            }

            scene.add(cloudGroup);
            return cloudGroup;
        }
        const clouds = createClouds();

        // Initialize player sheep
        const sheep = new Sheep();
        sheep.group.position.set(-10, 0, -10); // Start away from the copying machine
        scene.add(sheep.group);

        // Add white sheep to the meadow with grazing behavior
        function createWhiteSheep() {
            const whiteSheepArray = [];

            for (let i = 0; i < 15; i++) {
                const whiteSheep = new THREE.Group();

                // Body
                const bodyGeometry = new THREE.BoxGeometry(1.5, 1, 2);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1;
                body.castShadow = true;
                whiteSheep.add(body);

                // Head
                const headGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.set(0, 0.2, 0);
                head.castShadow = true;

                // Create head group to pivot at neck
                const headGroup = new THREE.Group();
                headGroup.position.set(0, 1.0, 1.2);
                headGroup.add(head);

                // Eyes (attached to head)
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.25, 0.3, 0.4);
                headGroup.add(leftEye);

                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.25, 0.3, 0.4);
                headGroup.add(rightEye);

                whiteSheep.add(headGroup);

                // Legs
                const legGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.8, 8);
                const legMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });

                const legPositions = [
                    [-0.5, 0.4, 0.6],
                    [0.5, 0.4, 0.6],
                    [-0.5, 0.4, -0.6],
                    [0.5, 0.4, -0.6]
                ];

                legPositions.forEach(pos => {
                    const leg = new THREE.Mesh(legGeometry, legMaterial);
                    leg.position.set(pos[0], pos[1], pos[2]);
                    leg.castShadow = true;
                    whiteSheep.add(leg);
                });

                // Ears
                const earGeometry = new THREE.ConeGeometry(0.2, 0.4, 8);
                const earMaterial = new THREE.MeshLambertMaterial({ color: 0xF0F0F0 });
                const leftEar = new THREE.Mesh(earGeometry, earMaterial);
                leftEar.position.set(-0.3, 1.6, 1.2);
                leftEar.rotation.z = 0.3;
                whiteSheep.add(leftEar);

                const rightEar = new THREE.Mesh(earGeometry, earMaterial);
                rightEar.position.set(0.3, 1.6, 1.2);
                rightEar.rotation.z = -0.3;
                whiteSheep.add(rightEar);

                // Position randomly in the meadow
                whiteSheep.position.x = (Math.random() - 0.5) * groundSize * 0.6;
                whiteSheep.position.z = (Math.random() - 0.5) * groundSize * 0.6;
                whiteSheep.rotation.y = Math.random() * Math.PI * 2;

                // Store references and state for animation
                whiteSheep.userData = {
                    headGroup: headGroup,
                    body: body,
                    grazeTime: Math.random() * 10,
                    grazeSpeed: 0.5 + Math.random() * 0.5,
                    velocity: new THREE.Vector3(0, 0, 0),
                    baseY: whiteSheep.position.y,
                    moveTimer: 10 + Math.random() * 50, // Time until next move (10-60s)
                    isMoving: false,
                    targetPosition: null,
                    moveSpeed: 2 + Math.random() * 2,
                    lastBleatTime: 0 // Track when sheep last bleated
                };

                scene.add(whiteSheep);
                whiteSheepArray.push(whiteSheep);
            }

            return whiteSheepArray;
        }
        const whiteSheeps = createWhiteSheep();

        // Minimap setup
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        const minimapSize = 200;
        const mapScale = minimapSize / (groundSize * 0.9); // Show slightly more than fence area

        function renderMinimap() {
            // Clear canvas
            minimapCtx.clearRect(0, 0, minimapSize, minimapSize);

            // Draw background (grass area)
            minimapCtx.fillStyle = 'rgba(76, 175, 80, 0.3)';
            minimapCtx.fillRect(0, 0, minimapSize, minimapSize);

            // Save context and apply rotation
            minimapCtx.save();

            // Translate to center of minimap
            minimapCtx.translate(minimapSize / 2, minimapSize / 2);

            // Rotate based on player rotation (negative because we want map to rotate opposite)
            minimapCtx.rotate(-sheep.group.rotation.y);

            // Helper function to convert world coordinates to minimap coordinates
            function worldToMinimap(worldX, worldZ) {
                const relativeX = (worldX - sheep.group.position.x) * mapScale;
                const relativeZ = -(worldZ - sheep.group.position.z) * mapScale;
                return { x: relativeX, y: relativeZ };
            }

            // Draw fence boundary
            const fenceSize = groundSize * 0.45;
            const fenceWidth = fenceSize * 2 * mapScale;
            const fenceCorner = worldToMinimap(-fenceSize, fenceSize);
            minimapCtx.strokeStyle = 'rgba(139, 69, 19, 0.8)';
            minimapCtx.lineWidth = 2;
            minimapCtx.strokeRect(fenceCorner.x, fenceCorner.y, fenceWidth, fenceWidth);

            // Draw farmhouse
            const farmhouseWorldX = groundSize * 0.35;
            const farmhouseWorldZ = groundSize * 0.35;
            const farmhousePos = worldToMinimap(farmhouseWorldX, farmhouseWorldZ);
            minimapCtx.fillStyle = 'rgba(204, 0, 0, 0.8)';
            minimapCtx.fillRect(
                farmhousePos.x - (6 * mapScale),
                farmhousePos.y - (5 * mapScale),
                12 * mapScale,
                10 * mapScale
            );

            // Draw copying machine
            const copyingMachinePos = worldToMinimap(0, 0);
            minimapCtx.fillStyle = 'rgba(224, 224, 224, 0.9)';
            minimapCtx.fillRect(
                copyingMachinePos.x - (2.25 * mapScale),
                copyingMachinePos.y - (1.75 * mapScale),
                4.5 * mapScale,
                3.5 * mapScale
            );

            // Draw trees
            minimapCtx.fillStyle = 'rgba(34, 139, 34, 0.6)';
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                const distance = groundSize * 0.4;
                const treeWorldX = Math.cos(angle) * distance;
                const treeWorldZ = Math.sin(angle) * distance;
                const treePos = worldToMinimap(treeWorldX, treeWorldZ);
                minimapCtx.beginPath();
                minimapCtx.arc(treePos.x, treePos.y, 3, 0, Math.PI * 2);
                minimapCtx.fill();
            }

            // Draw hay bales
            minimapCtx.fillStyle = 'rgba(222, 184, 135, 0.7)';
            hayBales.children.forEach((hayBale) => {
                const hayPos = worldToMinimap(hayBale.position.x, hayBale.position.z);
                minimapCtx.fillRect(hayPos.x - 1.5, hayPos.y - 1.5, 3, 3);
            });

            // Draw white sheep
            minimapCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            whiteSheeps.forEach((whiteSheep) => {
                const sheepPos = worldToMinimap(whiteSheep.position.x, whiteSheep.position.z);
                minimapCtx.beginPath();
                minimapCtx.arc(sheepPos.x, sheepPos.y, 2.5, 0, Math.PI * 2);
                minimapCtx.fill();
            });

            // Draw direction indicator (pointing up since we're centered)
            const directionLength = 8;
            minimapCtx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.moveTo(0, 0);
            minimapCtx.lineTo(0, -directionLength);
            minimapCtx.stroke();

            // Draw player dot (black sheep) at center
            minimapCtx.fillStyle = 'rgba(26, 26, 26, 1)';
            minimapCtx.strokeStyle = 'rgba(255, 255, 0, 1)';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.arc(0, 0, 4, 0, Math.PI * 2);
            minimapCtx.fill();
            minimapCtx.stroke();

            // Restore context
            minimapCtx.restore();
        }

        // Audio context for sound effects
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Function to play jump sound
        function playJumpSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Create a pleasant jump sound (quick upward pitch)
            oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.1);

            // Volume envelope for smooth sound
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);

            oscillator.type = 'sine';
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.2);
        }

        // Function to play sheep bleat sound
        function playBleatSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Create a sheep-like bleat sound (wavering pitch)
            oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
            oscillator.frequency.linearRampToValueAtTime(350, audioContext.currentTime + 0.1);
            oscillator.frequency.linearRampToValueAtTime(420, audioContext.currentTime + 0.2);
            oscillator.frequency.linearRampToValueAtTime(380, audioContext.currentTime + 0.35);

            // Volume envelope
            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.25, audioContext.currentTime + 0.1);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);

            oscillator.type = 'sawtooth'; // Sawtooth for more "animal-like" sound
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.4);
        }

        // Keyboard input
        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
        });
        window.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Mobile touch controls
        if (isMobile) {
            // Joystick state
            const joystickState = {
                active: false,
                x: 0, // -1 to 1
                y: 0  // -1 to 1
            };

            const joystick = document.getElementById('joystick');
            const joystickKnob = document.getElementById('joystick-knob');
            const joystickRadius = 70; // Half of joystick-base width (140px / 2)
            const knobMaxDistance = 40; // Maximum distance knob can move from center

            function updateJoystick(touch) {
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                // Calculate offset from center
                const offsetX = touch.clientX - centerX;
                const offsetY = touch.clientY - centerY;

                // Calculate distance and angle
                const distance = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
                const angle = Math.atan2(offsetY, offsetX);

                // Limit distance to knobMaxDistance
                const limitedDistance = Math.min(distance, knobMaxDistance);

                // Calculate knob position
                const knobX = Math.cos(angle) * limitedDistance;
                const knobY = Math.sin(angle) * limitedDistance;

                // Update knob visual position
                joystickKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;

                // Update joystick state (normalized -1 to 1)
                joystickState.x = knobX / knobMaxDistance;
                joystickState.y = knobY / knobMaxDistance;

                // Convert joystick position to key inputs
                // Forward/backward based on Y axis
                if (joystickState.y < -0.3) {
                    keys['ArrowUp'] = true;
                    keys['ArrowDown'] = false;
                } else if (joystickState.y > 0.3) {
                    keys['ArrowDown'] = true;
                    keys['ArrowUp'] = false;
                } else {
                    keys['ArrowUp'] = false;
                    keys['ArrowDown'] = false;
                }

                // Left/right based on X axis
                if (joystickState.x < -0.3) {
                    keys['ArrowLeft'] = true;
                    keys['ArrowRight'] = false;
                } else if (joystickState.x > 0.3) {
                    keys['ArrowRight'] = true;
                    keys['ArrowLeft'] = false;
                } else {
                    keys['ArrowLeft'] = false;
                    keys['ArrowRight'] = false;
                }
            }

            function resetJoystick() {
                joystickState.active = false;
                joystickState.x = 0;
                joystickState.y = 0;
                joystickKnob.style.transform = 'translate(-50%, -50%)';
                joystick.classList.remove('active');

                // Clear all directional keys
                keys['ArrowUp'] = false;
                keys['ArrowDown'] = false;
                keys['ArrowLeft'] = false;
                keys['ArrowRight'] = false;
            }

            // Joystick touch handlers
            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                joystickState.active = true;
                joystick.classList.add('active');
                updateJoystick(e.touches[0]);
            }, { passive: false });

            joystick.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (joystickState.active) {
                    updateJoystick(e.touches[0]);
                }
            }, { passive: false });

            joystick.addEventListener('touchend', (e) => {
                e.preventDefault();
                resetJoystick();
            }, { passive: false });

            joystick.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                resetJoystick();
            }, { passive: false });

            // Action buttons (jump and sprint)
            const actionButtons = {
                'btn-jump': 'Space',
                'btn-sprint': 'ShiftLeft'
            };

            Object.keys(actionButtons).forEach(btnId => {
                const button = document.getElementById(btnId);
                const keyCode = actionButtons[btnId];

                button.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    keys[keyCode] = true;
                    button.classList.add('pressed');
                }, { passive: false });

                button.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    keys[keyCode] = false;
                    button.classList.remove('pressed');
                }, { passive: false });

                button.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    keys[keyCode] = false;
                    button.classList.remove('pressed');
                }, { passive: false });
            });
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        const clock = new THREE.Clock();
        let cameraRotation = 0;

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            // Update sheep
            sheep.update(keys, delta);

            // Animate white sheep grazing and movement
            whiteSheeps.forEach((whiteSheep) => {
                const userData = whiteSheep.userData;
                userData.grazeTime += delta * userData.grazeSpeed;

                // Movement timer - decide when to move to new grazing spot
                if (!userData.isMoving) {
                    userData.moveTimer -= delta;
                    if (userData.moveTimer <= 0) {
                        // Time to move to a new spot
                        userData.isMoving = true;
                        userData.targetPosition = new THREE.Vector3(
                            (Math.random() - 0.5) * groundSize * 0.6,
                            0,
                            (Math.random() - 0.5) * groundSize * 0.6
                        );
                    }
                }

                // Move towards target position
                if (userData.isMoving && userData.targetPosition) {
                    const dx = userData.targetPosition.x - whiteSheep.position.x;
                    const dz = userData.targetPosition.z - whiteSheep.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);

                    if (distance > 0.5) {
                        // Store old position
                        const oldX = whiteSheep.position.x;
                        const oldZ = whiteSheep.position.z;

                        // Move towards target
                        const moveX = (dx / distance) * userData.moveSpeed * delta;
                        const moveZ = (dz / distance) * userData.moveSpeed * delta;
                        whiteSheep.position.x += moveX;
                        whiteSheep.position.z += moveZ;

                        // Check collision
                        const collision = checkCollision(whiteSheep.position.x, whiteSheep.position.z, 1.5);
                        if (collision.collided) {
                            // Revert position and pick new target
                            whiteSheep.position.x = oldX;
                            whiteSheep.position.z = oldZ;
                            userData.isMoving = false;
                            userData.targetPosition = null;
                            userData.moveTimer = 2 + Math.random() * 3; // Try again soon
                        } else {
                            // Rotate to face movement direction
                            const targetAngle = Math.atan2(dx, dz);
                            whiteSheep.rotation.y = targetAngle;
                        }
                    } else {
                        // Arrived at target
                        userData.isMoving = false;
                        userData.targetPosition = null;
                        userData.moveTimer = 10 + Math.random() * 50; // Reset timer for next move
                    }
                }

                // Head tilting animation for grazing - only when not moving
                if (!userData.isMoving) {
                    const grazeAngle = Math.sin(userData.grazeTime * 1.5) * 0.5 + 0.5; // 0 to 1
                    userData.headGroup.rotation.x = grazeAngle * 1.0; // Tilt forward and down (positive = down)
                } else {
                    // Head up when walking
                    userData.headGroup.rotation.x = 0;
                }
            });

            // Check collisions between player and white sheep
            whiteSheeps.forEach((whiteSheep) => {
                const dx = sheep.group.position.x - whiteSheep.position.x;
                const dz = sheep.group.position.z - whiteSheep.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                const collisionDistance = 2.5;

                if (distance < collisionDistance) {
                    // Calculate push direction
                    const pushX = -dx / distance;
                    const pushZ = -dz / distance;
                    const pushForce = (collisionDistance - distance) * 0.3;

                    // Apply bounce velocity to white sheep
                    whiteSheep.userData.velocity.x += pushX * pushForce;
                    whiteSheep.userData.velocity.z += pushZ * pushForce;

                    // Play bleat sound with cooldown (1 second between bleats)
                    const currentTime = Date.now() / 1000;
                    if (currentTime - whiteSheep.userData.lastBleatTime > 1.0) {
                        playBleatSound();
                        whiteSheep.userData.lastBleatTime = currentTime;
                    }
                }

                // Apply velocity and friction to white sheep
                whiteSheep.position.x += whiteSheep.userData.velocity.x;
                whiteSheep.position.z += whiteSheep.userData.velocity.z;
                whiteSheep.userData.velocity.multiplyScalar(0.85);

                // Keep white sheep within bounds
                const boundary = groundSize * 0.4;
                if (Math.abs(whiteSheep.position.x) > boundary) {
                    whiteSheep.position.x = Math.sign(whiteSheep.position.x) * boundary;
                    whiteSheep.userData.velocity.x *= -0.5;
                }
                if (Math.abs(whiteSheep.position.z) > boundary) {
                    whiteSheep.position.z = Math.sign(whiteSheep.position.z) * boundary;
                    whiteSheep.userData.velocity.z *= -0.5;
                }
            });

            // Camera follows sheep with lag on rotation
            cameraRotation += (sheep.group.rotation.y - cameraRotation) * 0.05;

            const cameraOffset = new THREE.Vector3(
                -Math.sin(cameraRotation) * 15,
                8,
                -Math.cos(cameraRotation) * 15
            );
            const targetPosition = sheep.group.position.clone().add(cameraOffset);
            camera.position.lerp(targetPosition, 0.08);
            camera.lookAt(sheep.group.position.x, sheep.group.position.y + 2, sheep.group.position.z);

            // Animate clouds
            clouds.children.forEach((cloud, index) => {
                cloud.position.x += 0.02 * (1 + index * 0.1);
                if (cloud.position.x > groundSize / 2) {
                    cloud.position.x = -groundSize / 2;
                }
            });

            renderer.render(scene, camera);

            // Update minimap
            renderMinimap();
        }
        animate();
    </script>
</body>
</html>
